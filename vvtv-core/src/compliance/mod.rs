use std::path::{Path, PathBuf};

use serde::{Deserialize, Serialize};
use thiserror::Error;

mod audit;
mod csam;
mod drm;

pub use audit::{
    ConsentLogEntry, LicenseAuditFinding, LicenseAuditFindingKind, LicenseAuditReport,
    LicenseAuditSummary, LicenseAuditor,
};
pub use csam::{CsamHashEntry, CsamScanFinding, CsamScanReport, CsamScanner};
pub use drm::{DrmDetectionConfig, DrmScanFinding, DrmScanReport, DrmScanner};

/// Result alias for compliance operations.
pub type ComplianceResult<T> = Result<T, ComplianceError>;

/// Errors generated by compliance scanners and auditors.
#[derive(Debug, Error)]
pub enum ComplianceError {
    /// Wrapper for [`std::io::Error`] including the file path when available.
    #[error("io error at {path}: {source}")]
    Io {
        source: std::io::Error,
        path: PathBuf,
    },
    /// JSON parsing error while reading structured logs.
    #[error("failed to parse json at {path}: {source}")]
    Json {
        source: serde_json::Error,
        path: PathBuf,
    },
    /// Failure while traversing directories.
    #[error("failed to walk directory {path}: {source}")]
    WalkDir {
        source: walkdir::Error,
        path: PathBuf,
    },
    /// Unexpected or malformed data detected during scanning.
    #[error("invalid compliance data: {0}")]
    InvalidData(String),
    /// Attempted to execute an operation without the required dataset or configuration.
    #[error("missing resource: {0}")]
    Missing(String),
}

impl ComplianceError {
    fn io<P: AsRef<Path>>(source: std::io::Error, path: P) -> Self {
        Self::Io {
            source,
            path: path.as_ref().to_path_buf(),
        }
    }

    fn json<P: AsRef<Path>>(source: serde_json::Error, path: P) -> Self {
        Self::Json {
            source,
            path: path.as_ref().to_path_buf(),
        }
    }

    fn walkdir<P: AsRef<Path>>(source: walkdir::Error, path: P) -> Self {
        Self::WalkDir {
            source,
            path: path.as_ref().to_path_buf(),
        }
    }
}

/// Aggregates compliance scanners and returns a consolidated summary.
#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct ComplianceSummary {
    /// Result of the consent/license log audit.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub license_audit: Option<LicenseAuditReport>,
    /// Result of DRM/EME pattern scanning.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub drm_scan: Option<DrmScanReport>,
    /// Result of CSAM hash scanning.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub csam_scan: Option<CsamScanReport>,
}

impl ComplianceSummary {
    /// Returns true when at least one audit produced findings.
    pub fn has_findings(&self) -> bool {
        self.license_audit
            .as_ref()
            .map(|audit| !audit.findings.is_empty())
            .unwrap_or(false)
            || self
                .drm_scan
                .as_ref()
                .map(|scan| !scan.findings.is_empty())
                .unwrap_or(false)
            || self
                .csam_scan
                .as_ref()
                .map(|scan| !scan.matches.is_empty())
                .unwrap_or(false)
    }
}

/// Configures the set of compliance checks to execute.
#[derive(Debug, Default, Clone, Serialize, Deserialize)]
pub struct ComplianceSuiteConfig {
    /// Directory containing consent/licensing logs in JSONL format.
    pub license_logs_dir: Option<PathBuf>,
    /// Directories that contain manifests and player artifacts to scan for DRM.
    pub drm_roots: Vec<PathBuf>,
    /// Directories with media assets to scan for CSAM hashes.
    pub csam_roots: Vec<PathBuf>,
    /// Optional path to a CSV/JSON hash database used for CSAM detection.
    pub csam_hash_db: Option<PathBuf>,
    /// Grace period in days before an expiring consent is flagged.
    pub expiry_grace_days: i64,
    /// Maximum number of days before a consent verification is considered stale.
    pub verification_max_age_days: i64,
}

impl ComplianceSuiteConfig {
    /// Creates a configuration with sensible defaults for grace windows.
    pub fn new() -> Self {
        Self {
            license_logs_dir: None,
            drm_roots: Vec::new(),
            csam_roots: Vec::new(),
            csam_hash_db: None,
            expiry_grace_days: 14,
            verification_max_age_days: 30,
        }
    }
}

/// Orchestrates the execution of all compliance scanners with a single call.
#[derive(Debug, Default, Clone)]
pub struct ComplianceSuite {
    config: ComplianceSuiteConfig,
    drm_config: DrmDetectionConfig,
}

impl ComplianceSuite {
    /// Creates a suite with the given configuration and default DRM patterns.
    pub fn new(config: ComplianceSuiteConfig) -> Self {
        Self {
            config,
            drm_config: DrmDetectionConfig::default(),
        }
    }

    /// Overrides the DRM detection patterns.
    pub fn with_drm_config(mut self, config: DrmDetectionConfig) -> Self {
        self.drm_config = config;
        self
    }

    /// Executes all configured compliance checks, returning a consolidated summary.
    pub fn run(&self) -> ComplianceResult<ComplianceSummary> {
        let mut summary = ComplianceSummary::default();

        if let Some(dir) = &self.config.license_logs_dir {
            let auditor = LicenseAuditor::new(
                chrono::Duration::days(self.config.expiry_grace_days),
                chrono::Duration::days(self.config.verification_max_age_days),
            );
            let report = auditor.audit_directory(dir)?;
            summary.license_audit = Some(report);
        }

        if !self.config.drm_roots.is_empty() {
            let scanner = DrmScanner::new(self.drm_config.clone());
            let mut merged = DrmScanReport::default();
            for root in &self.config.drm_roots {
                let report = scanner.scan_directory(root)?;
                merged.files_scanned += report.files_scanned;
                merged.findings.extend(report.findings);
            }
            summary.drm_scan = Some(merged);
        }

        if !self.config.csam_roots.is_empty() {
            let db_path = self
                .config
                .csam_hash_db
                .clone()
                .ok_or_else(|| ComplianceError::Missing("CSAM hash database".into()))?;
            let scanner = CsamScanner::from_database(db_path)?;
            let mut merged = CsamScanReport::default();
            for root in &self.config.csam_roots {
                let report = scanner.scan_directory(root)?;
                merged.files_scanned += report.files_scanned;
                merged.matches.extend(report.matches);
            }
            summary.csam_scan = Some(merged);
        }

        Ok(summary)
    }
}
